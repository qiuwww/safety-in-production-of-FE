# Code Review

结合别人的经验，选择符合实际需求的 Code Review 形式，设定一些必要的 Code Review 标准。

## 目标与原则

1. **提高代码质量**，及早发现程序潜在的缺陷
2. **规范项目结构**，避免冗余代码，方便别人阅读与维护
3. **促进团队内部知识共享**，相互学习，提高团队整体水平
4. **便捷交叉维护**

## 方式与规则

Code Review 的过程需要结合代码 PR 的过程，但是每一次的 PR 都进行 Code Review 也很耗费时间，不太现实，所以可以基于一下的方式与原则进行。

1. Code Review 需要结合代码 PR 的过程，所以要规范 PR
   1. 每个任务都新建 feature 进行开发
   2. 对于每次 PR 的 commit 有准确的描述
      1. 你改动了什么
      2. 解决了什么问题
      3. 需要代码 Review 的人留意那些影响比较大的改动
   3. 真正需要review的时候，一般这个时候代码都是发布到了测试环境的，所以要选择一个git的一个节点进行review。
2. 需要选择合适的时机进行 Code Review
   1. 对接接口完成之后，代码提测之前
   2. 代码发布之前，代码需要合并 master 的时候
3. Code Review，由相近开发任务的同学加上小组长，三个人进行，**由需 Review 代码的人讲解自己的代码**
4. Code Review 的目标是减少 bug，提高代码的可维护性，主要 Review 如下的面：
   1. ~~UI 还原度~~
   2. 是否都完成了设计文档的功能需求
   3. 关键部分的代码逻辑
   4. 项目结构，代码风格

## Code Review 基础标准

作为一个基础的标准，减少争议，寻找一种大多数人认可标准。

### 1. ESlint 规范

1. 需要符合基础设定的 ESlint 规则，使用 prettierrc+eslintrc 对代码进行基础规范
   1. 2 空格缩进
   2. 类型的声明，
   3. debugger 与 console

### 2. 命名规则

1. 项目与文件夹命名，项目名称符合文件夹命名规范，**中划线链接小写字符(kebab-case，短横线法)**；
2. **单文件组件命名规则**
   1. 组件类名使用**大写字母开头的形式(PascalCase，单词首字母大写命名)**，不使用 DemoComponent/index；
   2. **组件名应该始终是多个单词的**，根组件 App 除外；
   3. 组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾；
      1. `SearchButtonClear.vue`；
      2. `SearchInputQuery.vue`；
3. 路由命名，path 使用全小写，多个单词用 - 分开，name 与 path 保持一致；
4. 请求 service 命名，所有定义的接口以 api 开头小驼峰命名，尽量语义化，不要简写，`apiGetHomeList`；
5. 标签 class 属性 命名，class 和 id 的命名应该语义化，通过看名字就知道是干嘛的；全部小写，多个单词用连接线 - 连接，符合一般的语义化标准。

### 3. 项目结构

1. `package.json`文件：
   1. `.browserslist`，配置类的文件尽量集成到 package.json 中；
   2. 添加项目描述`description`，注意维护 version 与任务开发版本号一致；
2. README.md 文件添加必要的**项目说明**：

   1. 开发环境搭建与打包发布方式；
      1. 配置访问接口 host；
      2. 需要关注的公众号之类的；
      3. 打包发布方式说明，ci/cd ｜ Jenkins；
   2. 资源说明
      1. 接口文档地址；
      2. PRD；
      3. UI；

3. src 目录：
   1. assets，用到的图片资源，尽量存放在当前项目内；
   2. components，公共组件；
   3. constant，项目中用到的常量参数；
   4. pages，**分模块**页面存放，单独的业务组件就近存放；
   5. router，可以**分模块**存放路由；
   6. store，**分模块**对应页面；
   7. mixins，用于逻辑复用；
   8. styles，样式文件；
      1. common.less， 预设的公共样式，全局样式，样式重置；
      2. variables.less，less 变量文件；
   9. utils，**纯函数工具库**，需要添加描述和示例注释；
   10. filters，过滤器，需要声明作用和示例注释；
   11. directives，自定义指令，需要有注释；
   12. app.vue，main.ts，webview 可选；
4. types，ts 声明文件目录；
5. public，存放 index.html 和静态资源文件，jquery，lodash 等；

### 4. Vue 单文件组件

1. template，根标签，最好添加当前组件的名称 class，便于查找，`<div class="address-list"></div>`；
2. 使用 class 类型来声明组件，属性声明一般遵循如下的顺序：

   1. props
   2. data
   3. computed
   4. watch

   5. created、mounted、activited、update
   6. beforeRouteUpdate
   7. methods
   8. filter

3. 公共 components 放在`src/components`下；
4. 私有业务组件就近原则，`./components`；
5. **组件最好不超过 400 行**；

6. 可重用性，可复用性 & 组合

   1. **mixins**，业务代码[逻辑复用](https://cn.vuejs.org/v2/guide/mixins.html)，与业务相关的，比如，详情与列表中都有的**取消按钮操作**；
   2. DRY（Do not Repeat Yourself）原则：同一代码块**不应该重复**两次及以上；
   3. 注意**拆分组件**，
      1. 可依照功能进行拆分；
      2. 业务逻辑独立的模块抽离出来；
      3. 程序的每个功能是否都作为一个可辩识的代码块存在；

7. pages，**按照业务/逻辑相近**原则放在一起，对应 store/router/constant；

   1. 文件名最好直接能表达出当前页面的内容，要具有更强的语义化；
   2. 比如地址的增删改查页面都放在一起，统一存放在 address 目录下，其下分别创建需要的页面，pages/address/AddressList.vue | AddAndEditAddress.vue；

8. 组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法；
9. 应该优先通过 `Vuex` 管理全局状态，而不是通过 this.\$root 或一个全局事件总线；

### 5. 标签使用，模板文件

1. 遵循基本标签嵌套规则；
2. 行内元素内只可嵌套非自身的行内元素；
3. 语义化标签；
   1. `<Hx>`，h1~h6；
   2. `<p>`，段落标记；
   3. `<em>`和`<strong>`，强调；
   4. `<span>`组合文档中的行内元素；
   5. `<section>`，区段、`<header>`、`<footer>`；
   6. `<figure>` 标签用于对元素进行组合，图文组合；

### 6. ts/js

1. eslint 的统一，代码一致性基础规范；
2. 必要的注释：

   1. **函数功能的注释**，如 utils 下的功能函数，filter 的使用；
   2. **函数｜组件参数的注释**，通过参数名和类型可以轻松知道传递的参数规则；
   3. **关键｜复杂业务的注释**，对于比较复杂的或者关键的逻辑应该处注释；
   4. 对非常规行为和**边界情况**处理，添加描述/注释。

3. 统一 index.ts 文件导出目录内资源的方式，如，components/index.ts，utils/index.ts；
4. 清理（释放）资源：
   1. 闭包的释放；
   2. 全局变量的使用；
   3. 定时器是否随生命周期消除；
5. 必要的**设计模式**：
   1. 策略模式；
   2. 单例模式；
   3. 装饰器模式，@；
   4. 组合模式，`mixins`；
6. 常量 constant，全部大写，主要用到的地方有，一般都存放在 src/constant 下：
   1. 枚举类型，所有接口的参数或者返回参数都应该创建一个枚举类型，非 ts 项目，可以使用对象来表示；
   2. router 路径；
   3. vuex 的模块命名；
7. 函数的声明与调用，所有的程序调用都使用了正确的参数个数，是否有未定义出错的风险：
   1. **参数个数的问题**，超过两个最好使用对象形式传递参数；
   2. 必要的类型变量，给出默认值替代`&&`判断；
8. 必要的异常捕获处理；

   1. 捕获[Vue 实例的错误处理](https://cn.vuejs.org/v2/api/#errorHandler)；
   2. js 执行过程中的错误处理，注意：
      1. 调用了不存在的对象的属性；
      2. 非函数直接执行报错；
      3. 死循环；

9. 请求地址及协议的确认：
   1. 注意区分三个环境是用的 http 还是 https，可以统一省略`http|https`，利用浏览器的相对地址补全功能，让地址根据当前页面确定打开连接的协议，主要是方便在 https 和 http 之间切换。
10. 生产环境发布确认：
    1. 所有 console 信息需要去掉，敏感注释也要处理掉；
    2. 测试数据, 假数据, 旧代码, 删掉. (部分可用于下一期开发的业务代码, 请做好 TODO 标记, 避免误删)。
11. 循环和递归，注意判断边缘条件；
12. 按钮是否控制了单次点击；

### 7. 样式控制

1. 避免使用行类样式；
2. 样式统一加上 scoped, 避免污染，组件需要样式重置的，采用 deep 方式；
3. styles 下的公共样式及样式设置变量。

## 如何迅速完成 Code Review

1. 不要刻意地去寻找代码 bug，对于隐藏很深的 bug，没有必要在 Code Review 的时候去深入探究
2. 不要按照自己的编程风格去评论别人的代码，争议的地方，可以基于 3 基础的标准进行
3. 不要带着抨击和质疑别人能力的心态去进行代码评审

## 可能的问题

1. 元素的 class 使用 [bem 命名风格](https://github.com/Tencent/tmt-workflow/wiki/%E2%92%9B-[%E8%A7%84%E8%8C%83]--CSS-BEM-%E4%B9%A6%E5%86%99%E8%A7%84%E8%8C%83)(`type-block__element_modifier`)，还是一般的语义化的中划线组合(avatar-wrap，record-list)；

   1. element 组件库及 vant 组件库，基本是 bem 的这个规则；
   2. 第二种明显更方便一点，很多时候，第二种都不一定能都是具有语义化的组合；

2. 两种组件的命名规范，OrderList/index.vue，子组件存放在当前文件夹，还是 OrderList.vue，子组件统一存在模块下的 components 下；

3. review 的时间点；
4. 接口的地址声明为一个常量还是直接在 services/api.js 下使用，接口地址一般也只会在接口请求的时候使用?
5. 如何体现对代码的 review 过程？文档记录的形式还是邮件的形式？

